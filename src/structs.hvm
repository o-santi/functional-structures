// Author: Leonardo Santiago (@o-santi)


// ===============================
// The following equations are general functions
// that are sometimes needed to implement algorithms
// ================================

(IfElse 1 then else) = then
(IfElse 0 then else) = else

(Not 1) = 0
(Not 0) = 1

(<= a b) = (Not (> a b))
(>= a b) = (Not (< a b))

(Max a b) = (IfElse (> a b) a b)
(Min a b) = (IfElse (> a b) b a)

(Range 1 xs) = xs
(Range n xs) =
  let m = (- n 1)
  (Range m (Cons m xs))

(ReverseGo Nil ys) = ys
(ReverseGo (Cons x xs) ys) = (ReverseGo xs (Cons x ys))

(Randoms s 0) = (Nil)
(Randoms s l) = (Cons s (Randoms (% (+ (* s 1664525) 1013904223) 101) (- l 1)))

(Reverse list) = (ReverseGo list Nil)

(Append x Nil) = (Cons x Nil)
(Append x (Cons y ys)) = (Cons y (Append x ys))

// joins two lists
(Concat Nil ys )         = ys
(Concat (Cons x xs) ys)  = (Cons x (Concat xs ys))

(Concat xs ys) = (ConcatGo xs ys Nil)

(Filter f Nil) = Nil
(Filter f (Cons x xs)) =
  (IfElse (f x)
    (Cons x (Filter f xs))
    (Filter f xs))

// list length

(Length Nil) = 0
(Length (Cons x xs)) = (+ 1 (Length xs))


// Map

(Map f Nil)         = Nil
(Map f (Cons x xs)) = (Cons (f x) (Map f xs))

// Fold
// actually its foldl
// but for now it wont make any difference

(FoldGo f z Nil)         = z
(FoldGo f z (Cons x xs)) = (FoldGo f (f z x) xs)

(Fold f Nil)         = Nil
(Fold f (Cons x xs)) = (FoldGo f x xs)

Sum = λxλy(+ x y)

Mul = λxλy(* x y)

// Take

(Take 0 list) = Nil
(Take n (Cons x xs)) = (Cons x (Take (- n 1) xs))

// Drop

(Drop 0 list) = list
(Drop n (Cons x xs)) = (Drop (- n 1) xs) 

// Case
// this is the best i've thought yet
// it expects that `match` is a function that receives all it's args
// in the order given bellow

(Case (Nil)      fst_match snd_match) = (fst_match)
(Case (Cons a b) fst_match snd_match) = (snd_match a b)

// i dont exactly know how to generalize this without actually
// writing all constructors by hand

// idk how to do this?
// iterate through cases?
// try each one?
// how to back track?


// =============================================================
// List sorting algorithms
// the following algorithms are presented in the book
// Functional Algorithms Verified
// ===========================================================

// Insertion sort

(Insort x Nil) = (Cons x Nil)
(Insort x (Cons y ys)) =
  (IfElse (< x y)
    (Cons x (Cons y ys))
    (Cons y (Insort x ys)))

(ISort Nil) = Nil
(ISort (Cons x xs)) = (Insort x (ISort xs))

// Quicksort
// this is very bad
// and i mean very bad
// i still dont quite know why, but i will leave it as is for now

(Quicksort Nil) = Nil
(Quicksort (Cons x xs)) =
  let antes = (Quicksort (Filter λy(< y x) xs))
  let depois = (Quicksort (Filter λy(>= y x) xs))
  (Concat antes (Cons x depois))

// Topdown Merge sort

(Merge xs Nil) = xs
(Merge Nil ys) = ys
(Merge (Cons x xs) (Cons y ys)) =
  (IfElse (<= x y)
	      (Cons x (Merge xs (Cons y ys)))
	      (Cons y (Merge (Cons x xs) ys)))

(MSort xs) =
  let n = (Length xs)
  (IfElse (<= n 1)
    xs
    (Merge (MSort (Take (>> n 1) xs))
           (MSort (Drop (>> n 1) xs)))) 

// Bottom up Merge Sort
// Like top-down merge but recursively joins sets of lists
// until only one is left

(Merge_adj Nil) = Nil
(Merge_adj (Cons x Nil)) = (Cons x Nil)
(Merge_adj (Cons xs (Cons ys zs))) = (Cons (Merge xs ys) (Merge_adj zs))

(Merge_all Nil) = Nil
(Merge_all (Cons x Nil)) = x
(Merge_all xs)  = (Merge_all (Merge_adj xs))

(BotMSort xs) = (Merge_all (Map λx(Cons x Nil) xs))

// Natural Merge sort
// like bottom-up but efficient for small length aswell
// it will try to split the list into ascending and descending
// runs of elements

(Runs Nil) = Nil
(Runs (Cons x Nil)) = (Cons (Cons x Nil) Nil)
(Runs (Cons a (Cons b xs))) =
  (IfElse (< b a)
	  (Desc b (Cons a Nil) xs)
	  (Asc  b λk(Cons a k) xs))  // function that inserts `a` to a new list

// notice that ascending needs to append an item at the end
// and append is O(n) so it would end up making Asc O(n^2)
// to solve that we could use Cons and then reverse at the end
// but what i ended up doing (as the book did)
// is using lambda encoding for lists, make an "element" be a function that inserts
// an element into a list.
// so [a] -> @k (Cons a k)
// and when we want to force it into a list we simply apply it to Nil

(Asc a as Nil) = (Cons (as (Cons a Nil)) Nil) 
(Asc a as (Cons b bs)) =
  (IfElse (>= b a)
	  (Asc b λk(as (Cons a k)) bs)
	  (Cons (as (Cons a Nil)) (Runs (Cons b bs))))

(Desc a as Nil) = (Cons a as)
(Desc a as (Cons b bs)) =
  (IfElse (< b a)
	  (Desc b (Cons a as) bs)
	  (Cons (Cons a as) (Runs (Cons b bs))))

(NatMSort list) = (Merge_all (Runs list))


// Comparison with random n = 1000 
// Bot   =   2 066 614 rewrites
// Top   =   2 170 831 rewrites 
// Nat   =   3 215 566 rewrites (x1.5 ish?)
// QSort =   7 350 273 rewrites (x3.5 ish?) 
// ISort = 227 146 635 rewrites (x100)

// Insertion is obviously worse because of O(n^2)
// but i do think quicksort can be better (and i just did it poorly)
// of course, it was not written to use naturally use the parallelization and stuff like that of hvm


// ==============================
// Trees
// type Tree<T> {
//   Empty
//   Node(l: Tree<t>,x:T, r:Tree<T>)
// }
//
// bellow are some generic functions
// related to trees
// ==============================

(Single a) = (Node Empty a Empty)

(IsEmpty Empty)        = 1
(IsEmpty (Node _ _ _)) = 0

(MapTree f Empty) = Empty
(MapTree f (Node l x r)) = (Node (MapTree f l) (f x) (MapTree f r))

(Size (Empty)) = 0
(Size (Node l x r)) = (+ 1 (+ (Size l) (Size r)))

(Height (Empty)) = 0
(Height (Node l x r)) = (+ 1 (Max (Height l) (Height r)))

(MinHeight (Empty)) = 0
(MinHeight (Node l x r)) = (+ 1 (Min (Height l) (Height r)))

// |========================|
// BST - Binary search trees
// insertion, membership, deletion
// |========================|

// Following the book, i will use a little shortcut to compare 2 elements
// called (Compare a b) that will take the 3 paths for the comparison as argument.

(Compare a b less equal bigger) =
  (IfElse (< a b)
    less
    (IfElse (> a b)
      bigger
      equal))

// Membership in a BST
(IsIn _ (Empty))      = 0 // False
(IsIn a (Node l x r)) =
  (Compare a x
    (IsIn a l)  // if a < x then check in left branch
    1           // a == x -> True, 'cuz a is equal to an elem in the tree
    (IsIn a r)) // if a > x then check in right branch
    
// Insertion

(Insert a (Empty)) = (Single a)
(Insert a (Node l x r)) =
  (Compare a x
    (Node (Insert a l) x r) // if a < x then insert in left
    (Node l x r) // if a == x just insert in place 
    (Node l x (Insert a r))) // if a > x then insert in right

// note that this makes so that a tree cannot have multiple equal elements 

(Delete a (Empty)) = Empty
(Delete a (Node l x r)) =
  (Compare a x
    (Node (Delete a l) x r)
    (IfElse (IsEmpty r)
      l
      (Join l r)) // join the two branches (excluding a)
    (Node l x (Delete a r)))

(Join t (Empty)) = t
(Join (Empty) t) = t
(Join (Node t1 a t2) (Node t3 b t4)) =
  (Join.1 t1 t4 a b (Join t2 t3))
    
(Join.1 t1 t4 a b (Empty)) = (Node t1 a (Node Empty b t4))
(Join.1 t1 t4 a b (Node u2 x u3)) = (Node (Node t1 a u2) x (Node u3 b t4))


// this is basically a complete implementation of maps
// the problem is that insertion into that map
// does not necessarily preserve balance
// meaning that maybe Height(Tree) > Log(Size(Tree))
// which defeats the purpose of implementing Trees for fast lookup.

// now we will see some special trees that preserve balance

// |===========================|
// 2-3 Trees
//
// an example of a data type that preserves balance of the tree
// these are of the type
// type Tree23<T> {
//   Empty
//   Node(l: Tree23, a: T, r: Tree23)
//   Node(l: Tree23, a: T, m: Tree23, b: T, r: Tree23)
//  }
// where you can build a node with 3 children.
// |===========================|

// we will use the afore-defined function to normal BST's
// forget about type safety and such things like that for a second
(IsIn x (Node l a m b r)) =
  (Compare x a
    (IsIn x l)
    1 // true
    (Compare x b
      (IsIn x m)
      1 // true
      (IsIn x r)))

(TreeI (Success  t)) = t
(TreeI (Overflow l a r)) = (Node l a r)

(Insert23 x t) = (TreeI (Insert23.Go x t)) 

(Insert23.Go x (Empty)) = (Overflow Empty x Empty)
//(Insert23.Go x (Node l a r)) =
//(Compare x a
//      (


// |==============================|
// Red Black Trees
//
// type RBTree {
//   Empty
//   Red(l, a, r)
//   Black(l, a, r)
// }
// |==============================|

(Paint (Black) (Red l a r)) = (Black l a r)
(Paint (Black) (Black l a r)) = (Black l a r)

(InsertRB x t) = (Paint Black (InsertRB.Go x t))

(InsertRB.Go x (Empty)) = (Red Empty x Empty)
(InsertRB.Go x (Black l a r)) = 
  (Compare x a
    (BalanceLeft  (InsertRB.Go x l) a r)
    (Black l a r)
    (BalanceRight l a (InsertRB.Go x r)))

(InsertRB.Go x (Red l a r)) = 
  (Compare x a
    (Red (InsertRB.Go x l) a r)
    (Red l a r)
    (Red l a (InsertRB.Go x r)))
 
(BalanceLeft (Red (Red t1 a t2) b t3) c t4) = (Red (Black t1 a t2) b (Black t3 c t4))
(BalanceLeft (Red t1 a (Red t2 b t3)) c t4) = (Red (Black t1 a t2) b (Black t3 c t4))
(BalanceLeft t1 a t2) = (Black t1 a t2)

(BalanceRight t1 a (Red t2 b (Red t3 c t4))) = (Red (Black t1 a t2) b (Black t3 c t4))
(BalanceRight t1 a (Red (Red t2 b t3) c t4)) = (Red (Black t1 a t2) b (Black t3 c t4))
(BalanceRight t1 a t2)  = (Black t1 a t2) 

(FoldWith f z Nil) = z
(FoldWith f z (Cons x xs)) = (FoldWith f (f x z) xs)

(Height (Red l _ r)) = (+ 1 (Max (Height l) (Height r)))
(Height (Black l _ r)) = (+ 1 (Max (Height l) (Height r)))

(IsIn _ (Empty)) = 0 // false
(IsIn x (Red l a r)) =
  (Compare x a
    (IsIn x l)
    1
    (IsIn x r))
(IsIn x (Black l a r)) =
  (Compare x a
    (IsIn x l)
    1
    (IsIn x r))

(Main n) =
  let inserts = (Range n Nil) 
  let new = (FoldWith @a@b(InsertRB a b) Empty inserts)
  let test = (InsertRB 2 (InsertRB 1 Empty))
  (IsIn (- n 1) new)
